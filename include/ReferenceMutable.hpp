//
// Created by Mikhail Tsaritsyn on Jan 14, 2025.
//

#ifndef SAFE_REFERENCE_MUTABLE_HPP
#define SAFE_REFERENCE_MUTABLE_HPP
#include "internal/ReferenceLock.hpp"

namespace safe {
/**
 * @brief Wrapper around read-write reference to a value
 *
 * @tparam T Referenced type
 */
template <typename T>
    requires(!std::is_reference_v<T>)
class ReferenceMutable {
public:
    /**
     * @brief Construct the wrapper and acquire access to it
     *
     * @param ref Reference to borrow
     * @param lock Modifiable reference counter
     *
     * @note Should only be called by @link BorrowChecker @endlink
     *
     * @throws std::runtime_error If the lock is already acquired
     */
    constexpr explicit ReferenceMutable(T &ref, internal::ReferenceLock &lock) : _ref(ref), _lock(&lock) {
        _lock->lock();
    }

    ReferenceMutable(const ReferenceMutable &) noexcept            = delete;
    ReferenceMutable &operator=(const ReferenceMutable &) noexcept = delete;

    ReferenceMutable(ReferenceMutable &&other) noexcept : _ref(other._ref), _lock(other._lock) {
        other._lock = nullptr;
    }

    ReferenceMutable &operator=(ReferenceMutable &&other) noexcept;

    /**
     * @brief Releases the wrapped reference allowing to borrow it again
     */
    constexpr ~ReferenceMutable() noexcept;

    /**
     * @brief Update the referenced object
     *
     * Given value is copied or moved to the referenced object.
     *
     * @throws ... Whatever exceptions are generated by the assignment of the
     *             referenced object
     */
    constexpr ReferenceMutable &operator=(T &&value);

    // ReSharper disable once CppNonExplicitConversionOperator
    /**
     * @brief Get access to the underlying reference
     */
    [[nodiscard]] constexpr T &operator*() noexcept { return _ref; }

    /**
     * @brief Access methods of the underlying object
     */
    [[nodiscard]] constexpr T *operator->() noexcept { return &_ref; }

private:
    T &_ref; /// Reference to the tracked object

    /**
     * @brief Reference counter
     *
     * Can only be @p nullptr if the object was moved away.
     *
     * It is acquired on construction and released on destruction.
     * When @p true, no other references to the object can be borrowed.
     */
    internal::ReferenceLock *_lock;
};

template <typename T>
    requires(!std::is_reference_v<T>)
constexpr ReferenceMutable<T>::~ReferenceMutable() noexcept {
    try {
        if (_lock) _lock->unlock();
    } catch (std::runtime_error &) {
        std::cerr << "Double release of a mutable reference\n";
        exit(161);
    }
}

template <typename T>
    requires(!std::is_reference_v<T>)
constexpr ReferenceMutable<T> &ReferenceMutable<T>::operator=(T &&value) {
    _ref = std::forward<T>(value);
    return *this;
}

template <typename T>
    requires(!std::is_reference_v<T>)
ReferenceMutable<T> &ReferenceMutable<T>::operator=(ReferenceMutable &&other) noexcept {
    if (this == &other) return *this;
    _ref        = other._ref;
    _lock       = other._lock;
    other._lock = nullptr;
    return *this;
}
} // namespace safe

#endif // SAFE_REFERENCE_MUTABLE_HPP
